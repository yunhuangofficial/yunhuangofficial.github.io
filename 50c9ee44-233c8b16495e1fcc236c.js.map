{"version":3,"file":"50c9ee44-233c8b16495e1fcc236c.js","mappings":"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","sources":["webpack://v4/./node_modules/@splinetool/runtime/build/process.js"],"sourcesContent":["var Module = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function () {\n    let moduleArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var Module = moduleArg;\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = Object.assign({}, Module);\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = url => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = url => {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n        readAsync = (url, onload, onerror) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = () => {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n    } else {}\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.error.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    if (typeof WebAssembly != \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(text);\n      }\n    }\n    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      FS.ignorePermissions = false;\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n      what = \"Aborted(\" + what + \")\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += \". Build with -sASSERTIONS for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    var wasmBinaryFile;\n    wasmBinaryFile = \"process.wasm\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch == \"function\") {\n          return fetch(binaryFile, {\n            credentials: \"same-origin\"\n          }).then(response => {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n            }\n            return response[\"arrayBuffer\"]();\n          }).catch(() => getBinarySync(binaryFile));\n        }\n      }\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile).then(binary => WebAssembly.instantiate(binary, imports)).then(instance => instance).then(receiver, reason => {\n        err(\"failed to asynchronously prepare wasm: \".concat(reason));\n        abort(reason);\n      });\n    }\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") {\n        return fetch(binaryFile, {\n          credentials: \"same-origin\"\n        }).then(response => {\n          var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function (reason) {\n            err(\"wasm streaming compile failed: \".concat(reason));\n            err(\"falling back to ArrayBuffer instantiation\");\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n    function createWasm() {\n      var info = {\n        \"a\": wasmImports\n      };\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        wasmMemory = wasmExports[\"K\"];\n        updateMemoryViews();\n        wasmTable = wasmExports[\"O\"];\n        addOnInit(wasmExports[\"L\"]);\n        removeRunDependency(\"wasm-instantiate\");\n        return wasmExports;\n      }\n      addRunDependency(\"wasm-instantiate\");\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n          readyPromiseReject(e);\n        }\n      }\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    var callRuntimeCallbacks = callbacks => {\n      while (callbacks.length > 0) {\n        callbacks.shift()(Module);\n      }\n    };\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 24;\n      this.set_type = function (type) {\n        HEAPU32[this.ptr + 4 >> 2] = type;\n      };\n      this.get_type = function () {\n        return HEAPU32[this.ptr + 4 >> 2];\n      };\n      this.set_destructor = function (destructor) {\n        HEAPU32[this.ptr + 8 >> 2] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAPU32[this.ptr + 8 >> 2];\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[this.ptr + 12 >> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[this.ptr + 12 >> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[this.ptr + 13 >> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[this.ptr + 13 >> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n      };\n      this.set_adjusted_ptr = function (adjustedPtr) {\n        HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n      };\n      this.get_adjusted_ptr = function () {\n        return HEAPU32[this.ptr + 16 >> 2];\n      };\n      this.get_exception_ptr = function () {\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\n        if (isPointer) {\n          return HEAPU32[this.excPtr >> 2];\n        }\n        var adjusted = this.get_adjusted_ptr();\n        if (adjusted !== 0) return adjusted;\n        return this.excPtr;\n      };\n    }\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    var ___cxa_throw = (ptr, type, destructor) => {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw exceptionLast;\n    };\n    var tupleRegistrations = {};\n    var runDestructors = destructors => {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    };\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var InternalError;\n    var throwInternalError = message => {\n      throw new InternalError(message);\n    };\n    var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach((dt, i) => {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(() => {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    };\n    var __embind_finalize_value_array = rawTupleType => {\n      var reg = tupleRegistrations[rawTupleType];\n      delete tupleRegistrations[rawTupleType];\n      var elements = reg.elements;\n      var elementsLength = elements.length;\n      var elementTypes = elements.map(elt => elt.getterReturnType).concat(elements.map(elt => elt.setterArgumentType));\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      whenDependentTypesAreResolved([rawTupleType], elementTypes, function (elementTypes) {\n        elements.forEach((elt, i) => {\n          var getterReturnType = elementTypes[i];\n          var getter = elt.getter;\n          var getterContext = elt.getterContext;\n          var setterArgumentType = elementTypes[i + elementsLength];\n          var setter = elt.setter;\n          var setterContext = elt.setterContext;\n          elt.read = ptr => getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n          elt.write = (ptr, o) => {\n            var destructors = [];\n            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n            runDestructors(destructors);\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": ptr => {\n            var rv = new Array(elementsLength);\n            for (var i = 0; i < elementsLength; ++i) {\n              rv[i] = elements[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": (destructors, o) => {\n            if (elementsLength !== o.length) {\n              throw new TypeError(\"Incorrect number of tuple elements for \".concat(reg.name, \": expected=\").concat(elementsLength, \", actual=\").concat(o.length));\n            }\n            var ptr = rawConstructor();\n            for (var i = 0; i < elementsLength; ++i) {\n              elements[i].write(ptr, o[i]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": GenericWireTypeSize,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    };\n    var structRegistrations = {};\n    var __embind_finalize_value_object = structType => {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords.map(field => field.getterReturnType).concat(fieldRecords.map(field => field.setterArgumentType));\n      whenDependentTypesAreResolved([structType], fieldTypes, fieldTypes => {\n        var fields = {};\n        fieldRecords.forEach((field, i) => {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: ptr => getterReturnType[\"fromWireType\"](getter(getterContext, ptr)),\n            write: (ptr, o) => {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n              runDestructors(destructors);\n            }\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": ptr => {\n            var rv = {};\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": (destructors, o) => {\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError(\"Missing field: \\\"\".concat(fieldName, \"\\\"\"));\n              }\n            }\n            var ptr = rawConstructor();\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": GenericWireTypeSize,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    };\n    var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {};\n    var embind_init_charCodes = () => {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    };\n    var embind_charCodes;\n    var readLatin1String = ptr => {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    };\n    var BindingError;\n    var throwBindingError = message => {\n      throw new BindingError(message);\n    };\n    function sharedRegisterType(rawType, registeredInstance) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError(\"type \\\"\".concat(name, \"\\\" must have a positive integer typeid pointer\"));\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\".concat(name, \"' twice\"));\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(cb => cb());\n      }\n    }\n    function registerType(rawType, registeredInstance) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n      return sharedRegisterType(rawType, registeredInstance, options);\n    }\n    var GenericWireTypeSize = 8;\n    var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function (wt) {\n          return !!wt;\n        },\n        \"toWireType\": function (destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": function (pointer) {\n          return this[\"fromWireType\"](HEAPU8[pointer]);\n        },\n        destructorFunction: null\n      });\n    };\n    var shallowCopyInternalPointer = o => ({\n      count: o.count,\n      deleteScheduled: o.deleteScheduled,\n      preservePointerOnDelete: o.preservePointerOnDelete,\n      ptr: o.ptr,\n      ptrType: o.ptrType,\n      smartPtr: o.smartPtr,\n      smartPtrType: o.smartPtrType\n    });\n    var throwInstanceAlreadyDeleted = obj => {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    };\n    var finalizationRegistry = false;\n    var detachFinalizer = handle => {};\n    var runDestructor = $$ => {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    };\n    var releaseClassHandle = $$ => {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    };\n    var downcastPointer = (ptr, ptrClass, desiredClass) => {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    };\n    var registeredPointers = {};\n    var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;\n    var getLiveInheritedInstances = () => {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    };\n    var deletionQueue = [];\n    var flushPendingDeletes = () => {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    };\n    var delayFunction;\n    var setDelayFunction = fn => {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    };\n    var init_embind = () => {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    };\n    var registeredInstances = {};\n    var getBasestPointer = (class_, ptr) => {\n      if (ptr === undefined) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    };\n    var getInheritedInstance = (class_, ptr) => {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    };\n    var makeClassHandle = (prototype, record) => {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    };\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    var attachFinalizer = handle => {\n      if (\"undefined\" === typeof FinalizationRegistry) {\n        attachFinalizer = handle => handle;\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry(info => {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = handle => {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          var info = {\n            $$: $$\n          };\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = handle => finalizationRegistry.unregister(handle);\n      return attachFinalizer(handle);\n    };\n    var init_ClassHandle = () => {\n      Object.assign(ClassHandle.prototype, {\n        \"isAliasOf\"(other) {\n          if (!(this instanceof ClassHandle)) {\n            return false;\n          }\n          if (!(other instanceof ClassHandle)) {\n            return false;\n          }\n          var leftClass = this.$$.ptrType.registeredClass;\n          var left = this.$$.ptr;\n          other.$$ = other.$$;\n          var rightClass = other.$$.ptrType.registeredClass;\n          var right = other.$$.ptr;\n          while (leftClass.baseClass) {\n            left = leftClass.upcast(left);\n            leftClass = leftClass.baseClass;\n          }\n          while (rightClass.baseClass) {\n            right = rightClass.upcast(right);\n            rightClass = rightClass.baseClass;\n          }\n          return leftClass === rightClass && left === right;\n        },\n        \"clone\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.preservePointerOnDelete) {\n            this.$$.count.value += 1;\n            return this;\n          } else {\n            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n              $$: {\n                value: shallowCopyInternalPointer(this.$$)\n              }\n            }));\n            clone.$$.count.value += 1;\n            clone.$$.deleteScheduled = false;\n            return clone;\n          }\n        },\n        \"delete\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError(\"Object already scheduled for deletion\");\n          }\n          detachFinalizer(this);\n          releaseClassHandle(this.$$);\n          if (!this.$$.preservePointerOnDelete) {\n            this.$$.smartPtr = undefined;\n            this.$$.ptr = undefined;\n          }\n        },\n        \"isDeleted\"() {\n          return !this.$$.ptr;\n        },\n        \"deleteLater\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError(\"Object already scheduled for deletion\");\n          }\n          deletionQueue.push(this);\n          if (deletionQueue.length === 1 && delayFunction) {\n            delayFunction(flushPendingDeletes);\n          }\n          this.$$.deleteScheduled = true;\n          return this;\n        }\n      });\n    };\n    function ClassHandle() {}\n    var char_0 = 48;\n    var char_9 = 57;\n    var makeLegalFunctionName = name => {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\".concat(name);\n      }\n      return name;\n    };\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return {\n        [name]: function () {\n          return body.apply(this, arguments);\n        }\n      }[name];\n    }\n    var ensureOverloadTable = (proto, methodName, humanName) => {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\".concat(humanName, \"' called with an invalid number of arguments (\").concat(arguments.length, \") - expects one of (\").concat(proto[methodName].overloadTable, \")!\"));\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    };\n    var exposePublicSymbol = (name, value, numArguments) => {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\".concat(name, \"' twice\"));\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\".concat(numArguments, \")!\"));\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    };\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    var upcastPointer = (ptr, ptrClass, desiredClass) => {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \".concat(desiredClass.name, \", got an instance of \").concat(ptrClass.name));\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    };\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \".concat(this.name));\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(\"Cannot pass \\\"\".concat(embindRepr(handle), \"\\\" as a \").concat(this.name));\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \".concat(this.name));\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError(\"Cannot pass \\\"\".concat(embindRepr(handle), \"\\\" as a \").concat(this.name));\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle[\"delete\"]()));\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \".concat(this.name));\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(\"Cannot pass \\\"\".concat(embindRepr(handle), \"\\\" as a \").concat(this.name));\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function readPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n    var init_RegisteredPointer = () => {\n      Object.assign(RegisteredPointer.prototype, {\n        getPointee(ptr) {\n          if (this.rawGetPointee) {\n            ptr = this.rawGetPointee(ptr);\n          }\n          return ptr;\n        },\n        destructor(ptr) {\n          if (this.rawDestructor) {\n            this.rawDestructor(ptr);\n          }\n        },\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": readPointer,\n        \"deleteObject\"(handle) {\n          if (handle !== null) {\n            handle[\"delete\"]();\n          }\n        },\n        \"fromWireType\": RegisteredPointer_fromWireType\n      });\n    };\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n    var replacePublicSymbol = (name, value, numArguments) => {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    };\n    var dynCallLegacy = (sig, ptr, args) => {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    };\n    var wasmTableMirror = [];\n    var wasmTable;\n    var getWasmTableEntry = funcPtr => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    };\n    var dynCall = (sig, ptr, args) => {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      var rtn = getWasmTableEntry(ptr).apply(null, args);\n      return rtn;\n    };\n    var getDynCaller = (sig, ptr) => {\n      var argCache = [];\n      return function () {\n        argCache.length = 0;\n        Object.assign(argCache, arguments);\n        return dynCall(sig, ptr, argCache);\n      };\n    };\n    var embind__requireFunction = (signature, rawFunction) => {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp != \"function\") {\n        throwBindingError(\"unknown function pointer with signature \".concat(signature, \": \").concat(rawFunction));\n      }\n      return fp;\n    };\n    var extendError = (baseErrorType, errorName) => {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return \"\".concat(this.name, \": \").concat(this.message);\n        }\n      };\n      return errorClass;\n    };\n    var UnboundTypeError;\n    var getTypeName = type => {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    };\n    var throwUnboundTypeError = (message, types) => {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(\"\".concat(message, \": \") + unboundTypes.map(getTypeName).join([\", \"]));\n    };\n    var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) => {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(\"Cannot construct \".concat(name, \" due to unbound types\"), [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \".concat(name, \" with invalid number of parameters (\").concat(arguments.length, \") - expected (\").concat(Object.keys(registeredClass.constructor_body).toString(), \") parameters instead!\"));\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        if (registeredClass.baseClass) {\n          if (registeredClass.baseClass.__derivedClasses === undefined) {\n            registeredClass.baseClass.__derivedClasses = [];\n          }\n          registeredClass.baseClass.__derivedClasses.push(registeredClass);\n        }\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    };\n    var heap32VectorToArray = (count, firstElement) => {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAPU32[firstElement + i * 4 >> 2]);\n      }\n      return array;\n    };\n    function newFunc(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \".concat(typeof constructor, \" which is not a function\"));\n      }\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody = \"\\n        return function \".concat(makeLegalFunctionName(humanName), \"(\").concat(argsList, \") {\\n        if (arguments.length !== \").concat(argCount - 2, \") {\\n          throwBindingError('function \").concat(humanName, \" called with ' + arguments.length + ' arguments, expected \").concat(argCount - 2, \"');\\n        }\");\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {}\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      return newFunc(Function, args1).apply(null, args2);\n    }\n    var __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) => {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"constructor \".concat(classType.name);\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\".concat(argCount - 1, \") for class '\").concat(classType.name, \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\"));\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\n          throwUnboundTypeError(\"Cannot construct \".concat(classType.name, \" due to unbound types\"), rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, argTypes => {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    };\n    var __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) => {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"\".concat(classType.name, \".\").concat(methodName);\n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \".concat(humanName, \" due to unbound types\"), rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    };\n    var validateThis = (this_, classType, humanName) => {\n      if (!(this_ instanceof Object)) {\n        throwBindingError(\"\".concat(humanName, \" with invalid \\\"this\\\": \").concat(this_));\n      }\n      if (!(this_ instanceof classType.registeredClass.constructor)) {\n        throwBindingError(\"\".concat(humanName, \" incompatible with \\\"this\\\" of type \").concat(this_.constructor.name));\n      }\n      if (!this_.$$.ptr) {\n        throwBindingError(\"cannot call emscripten binding method \".concat(humanName, \" on deleted object\"));\n      }\n      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n    };\n    var __embind_register_class_property = (classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {\n      fieldName = readLatin1String(fieldName);\n      getter = embind__requireFunction(getterSignature, getter);\n      whenDependentTypesAreResolved([], [classType], function (classType) {\n        classType = classType[0];\n        var humanName = \"\".concat(classType.name, \".\").concat(fieldName);\n        var desc = {\n          get() {\n            throwUnboundTypeError(\"Cannot access \".concat(humanName, \" due to unbound types\"), [getterReturnType, setterArgumentType]);\n          },\n          enumerable: true,\n          configurable: true\n        };\n        if (setter) {\n          desc.set = () => throwUnboundTypeError(\"Cannot access \".concat(humanName, \" due to unbound types\"), [getterReturnType, setterArgumentType]);\n        } else {\n          desc.set = v => throwBindingError(humanName + \" is a read-only property\");\n        }\n        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {\n          var getterReturnType = types[0];\n          var desc = {\n            get() {\n              var ptr = validateThis(this, classType, humanName + \" getter\");\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            enumerable: true\n          };\n          if (setter) {\n            setter = embind__requireFunction(setterSignature, setter);\n            var setterArgumentType = types[1];\n            desc.set = function (v) {\n              var ptr = validateThis(this, classType, humanName + \" setter\");\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n              runDestructors(destructors);\n            };\n          }\n          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n          return [];\n        });\n        return [];\n      });\n    };\n    function handleAllocatorInit() {\n      Object.assign(HandleAllocator.prototype, {\n        get(id) {\n          return this.allocated[id];\n        },\n        has(id) {\n          return this.allocated[id] !== undefined;\n        },\n        allocate(handle) {\n          var id = this.freelist.pop() || this.allocated.length;\n          this.allocated[id] = handle;\n          return id;\n        },\n        free(id) {\n          this.allocated[id] = undefined;\n          this.freelist.push(id);\n        }\n      });\n    }\n    function HandleAllocator() {\n      this.allocated = [undefined];\n      this.freelist = [];\n    }\n    var emval_handles = new HandleAllocator();\n    var __emval_decref = handle => {\n      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n        emval_handles.free(handle);\n      }\n    };\n    var count_emval_handles = () => {\n      var count = 0;\n      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\n        if (emval_handles.allocated[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    };\n    var init_emval = () => {\n      emval_handles.allocated.push({\n        value: undefined\n      }, {\n        value: null\n      }, {\n        value: true\n      }, {\n        value: false\n      });\n      emval_handles.reserved = emval_handles.allocated.length;\n      Module[\"count_emval_handles\"] = count_emval_handles;\n    };\n    var Emval = {\n      toValue: handle => {\n        if (!handle) {\n          throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n        }\n        return emval_handles.get(handle).value;\n      },\n      toHandle: value => {\n        switch (value) {\n          case undefined:\n            return 1;\n          case null:\n            return 2;\n          case true:\n            return 3;\n          case false:\n            return 4;\n          default:\n            {\n              return emval_handles.allocate({\n                refcount: 1,\n                value: value\n              });\n            }\n        }\n      }\n    };\n    var __embind_register_emval = (rawType, name) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": handle => {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        \"toWireType\": (destructors, value) => Emval.toHandle(value),\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    };\n    var enumReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed ? function (pointer) {\n            return this[\"fromWireType\"](HEAP8[pointer >> 0]);\n          } : function (pointer) {\n            return this[\"fromWireType\"](HEAPU8[pointer >> 0]);\n          };\n        case 2:\n          return signed ? function (pointer) {\n            return this[\"fromWireType\"](HEAP16[pointer >> 1]);\n          } : function (pointer) {\n            return this[\"fromWireType\"](HEAPU16[pointer >> 1]);\n          };\n        case 4:\n          return signed ? function (pointer) {\n            return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n          } : function (pointer) {\n            return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n          };\n        default:\n          throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n      }\n    };\n    var __embind_register_enum = (rawType, name, size, isSigned) => {\n      name = readLatin1String(name);\n      function ctor() {}\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        \"fromWireType\": function (c) {\n          return this.constructor.values[c];\n        },\n        \"toWireType\": (destructors, c) => c.value,\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": enumReadValueFromPointer(name, size, isSigned),\n        destructorFunction: null\n      });\n      exposePublicSymbol(name, ctor);\n    };\n    var requireRegisteredType = (rawType, humanName) => {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    };\n    var __embind_register_enum_value = (rawEnumType, name, enumValue) => {\n      var enumType = requireRegisteredType(rawEnumType, \"enum\");\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {\n          value: enumValue\n        },\n        constructor: {\n          value: createNamedFunction(\"\".concat(enumType.name, \"_\").concat(name), function () {})\n        }\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    };\n    var embindRepr = v => {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = typeof v;\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    };\n    var floatReadValueFromPointer = (name, width) => {\n      switch (width) {\n        case 4:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 8:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"invalid float width (\".concat(width, \"): \").concat(name));\n      }\n    };\n    var __embind_register_float = (rawType, name, size) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": value => value,\n        \"toWireType\": (destructors, value) => value,\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": floatReadValueFromPointer(name, size),\n        destructorFunction: null\n      });\n    };\n    var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) => {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function () {\n        throwUnboundTypeError(\"Cannot call \".concat(name, \" due to unbound types\"), argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n        return [];\n      });\n    };\n    var integerReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed ? pointer => HEAP8[pointer >> 0] : pointer => HEAPU8[pointer >> 0];\n        case 2:\n          return signed ? pointer => HEAP16[pointer >> 1] : pointer => HEAPU16[pointer >> 1];\n        case 4:\n          return signed ? pointer => HEAP32[pointer >> 2] : pointer => HEAPU32[pointer >> 2];\n        default:\n          throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n      }\n    };\n    var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var fromWireType = value => value;\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = value => value << bitshift >>> bitshift;\n      }\n      var isUnsignedType = name.includes(\"unsigned\");\n      var checkAssertions = (value, toTypeName) => {};\n      var toWireType;\n      if (isUnsignedType) {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value >>> 0;\n        };\n      } else {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value;\n        };\n      }\n      registerType(primitiveType, {\n        name: name,\n        \"fromWireType\": fromWireType,\n        \"toWireType\": toWireType,\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\n        destructorFunction: null\n      });\n    };\n    var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        var size = HEAPU32[handle >> 2];\n        var data = HEAPU32[handle + 4 >> 2];\n        return new TA(HEAP8.buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": decodeMemoryView,\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    };\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    var lengthBytesUTF8 = str => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n    var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = \"\";\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        }\n      }\n      return str;\n    };\n    var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    var __embind_register_std_string = (rawType, name) => {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\"(value) {\n          var length = HEAPU32[value >> 2];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\"(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == \"string\";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[base >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n                HEAPU8[ptr + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": readPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    };\n    var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = \"\";\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    };\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    };\n    var lengthBytesUTF16 = str => str.length * 2;\n    var UTF32ToString = (ptr, maxBytesToRead) => {\n      var i = 0;\n      var str = \"\";\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    };\n    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    };\n    var lengthBytesUTF32 = str => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    };\n    var __embind_register_std_wstring = (rawType, charSize, name) => {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = () => HEAPU16;\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = () => HEAPU32;\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": value => {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": (destructors, value) => {\n          if (!(typeof value == \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \".concat(name));\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": GenericWireTypeSize,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    };\n    var __embind_register_value_array = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) => {\n      tupleRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        elements: []\n      };\n    };\n    var __embind_register_value_array_element = (rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {\n      tupleRegistrations[rawTupleType].elements.push({\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    };\n    var __embind_register_value_object = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) => {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: []\n      };\n    };\n    var __embind_register_value_object_field = (structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    };\n    var __embind_register_void = (rawType, name) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        \"argPackAdvance\": 0,\n        \"fromWireType\": () => undefined,\n        \"toWireType\": (destructors, o) => undefined\n      });\n    };\n    var __emval_incref = handle => {\n      if (handle > 4) {\n        emval_handles.get(handle).refcount += 1;\n      }\n    };\n    var __emval_take_value = (type, arg) => {\n      type = requireRegisteredType(type, \"_emval_take_value\");\n      var v = type[\"readValueFromPointer\"](arg);\n      return Emval.toHandle(v);\n    };\n    var _abort = () => {\n      abort(\"\");\n    };\n    var _emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n    var getHeapMax = () => 2147483648;\n    var growMemory = size => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {}\n    };\n    var _emscripten_resize_heap = requestedSize => {\n      var oldSize = HEAPU8.length;\n      requestedSize >>>= 0;\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    };\n    var ENV = {};\n    var getExecutableName = () => thisProgram || \"./this.program\";\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          \"USER\": \"web_user\",\n          \"LOGNAME\": \"web_user\",\n          \"PATH\": \"/\",\n          \"PWD\": \"/\",\n          \"HOME\": \"/home/web_user\",\n          \"LANG\": lang,\n          \"_\": getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(\"\".concat(x, \"=\").concat(env[x]));\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n      HEAP8[buffer >> 0] = 0;\n    };\n    var PATH = {\n      isAbs: path => path.charAt(0) === \"/\",\n      splitPath: filename => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n        return parts;\n      },\n      normalize: path => {\n        var isAbsolute = PATH.isAbs(path),\n          trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(p => !!p), !isAbsolute).join(\"/\");\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: path => {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          return \".\";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: path => {\n        if (path === \"/\") return \"/\";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: function () {\n        var paths = Array.prototype.slice.call(arguments);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: (l, r) => PATH.normalize(l + \"/\" + r)\n    };\n    var initRandomFill = () => {\n      if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") {\n        return view => crypto.getRandomValues(view);\n      } else abort(\"initRandomDevice\");\n    };\n    var randomFill = view => (randomFill = initRandomFill())(view);\n    var PATH_FS = {\n      resolve: function () {\n        var resolvedPath = \"\",\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n          if (typeof path != \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(p => !!p), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var FS_stdin_getChar_buffer = [];\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n          result = window.prompt(\"Input: \");\n          if (result !== null) {\n            result += \"\\n\";\n          }\n        } else if (typeof readline == \"function\") {\n          result = readline();\n          if (result !== null) {\n            result += \"\\n\";\n          }\n        }\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {},\n      shutdown() {},\n      register(dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        }\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var mmapAlloc = size => {\n      abort();\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n          old_node.parent = new_dir;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = [\".\", \"..\"];\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            HEAP8.set(contents, ptr);\n          }\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = !noRunDep ? getUniqueRunDependency(\"al \".concat(url)) : \"\";\n      readAsync(url, arrayBuffer => {\n        assert(arrayBuffer, \"Loading data file \\\"\".concat(url, \"\\\" failed (no arrayBuffer).\"));\n        onload(new Uint8Array(arrayBuffer));\n        if (dep) removeRunDependency(dep);\n      }, event => {\n        if (onerror) {\n          onerror();\n        } else {\n          throw \"Loading data file \\\"\".concat(url, \"\\\" failed.\");\n        }\n      });\n      if (dep) addRunDependency(dep);\n    };\n    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    var preloadPlugins = Module[\"preloadPlugins\"] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      if (typeof Browser != \"undefined\") Browser.init();\n      var handled = false;\n      preloadPlugins.forEach(plugin => {\n        if (handled) return;\n        if (plugin[\"canHandle\"](fullname)) {\n          plugin[\"handle\"](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(\"cp \".concat(fullname));\n      function processData(byteArray) {\n        function finish(byteArray) {\n          if (preFinish) preFinish();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n          }\n          if (onload) onload();\n          removeRunDependency(dep);\n        }\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n          if (onerror) onerror();\n          removeRunDependency(dep);\n        })) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == \"string\") {\n        asyncLoad(url, byteArray => processData(byteArray), onerror);\n      } else {\n        processData(url);\n      }\n    };\n    var FS_modeStringToFlags = str => {\n      var flagModes = {\n        \"r\": 0,\n        \"r+\": 2,\n        \"w\": 512 | 64 | 1,\n        \"w+\": 512 | 64 | 2,\n        \"a\": 1024 | 64 | 1,\n        \"a+\": 1024 | 64 | 2\n      };\n      var flags = flagModes[str];\n      if (typeof flags == \"undefined\") {\n        throw new Error(\"Unknown file open mode: \".concat(str));\n      }\n      return flags;\n    };\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      lookupPath(path) {\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        path = PATH_FS.resolve(path);\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts);\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = path.split(\"/\").filter(p => !!p);\n        var current = FS.root;\n        var current_path = \"/\";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count + 1\n              });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? \"\".concat(mount, \"/\").concat(path) : mount + path;\n          }\n          path = path ? \"\".concat(node.name, \"/\").concat(path) : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n        if (flag & 512) {\n          perms += \"w\";\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        var errCode = FS.nodePermissions(dir, \"x\");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, \"wx\");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: fd => FS.streams[fd],\n      createStream(stream) {\n        let fd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        if (!FS.FSStream) {\n          FS.FSStream = function () {\n            this.shared = {};\n          };\n          FS.FSStream.prototype = {};\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              get() {\n                return this.node;\n              },\n              set(val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get() {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get() {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get() {\n                return this.flags & 1024;\n              }\n            },\n            flags: {\n              get() {\n                return this.shared.flags;\n              },\n              set(val) {\n                this.shared.flags = val;\n              }\n            },\n            position: {\n              get() {\n                return this.shared.position;\n              },\n              set(val) {\n                this.shared.position = val;\n              }\n            }\n          });\n        }\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: dev => dev >> 8,\n      minor: dev => dev & 255,\n      makedev: (ma, mi) => ma << 8 | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: dev => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == \"function\") {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \".concat(FS.syncFSRequests, \" FS.syncfs operations in flight at once, probably just doing extra work\"));\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach(mount => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(hash => {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, {\n          parent: true\n        });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, {\n          parent: true\n        });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, \"w\");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, \"w\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open(path, flags, mode) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n        mode = typeof mode == \"undefined\" ? 438 : mode;\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n        flags &= ~(128 | 512 | 131072);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          ungotten: [],\n          error: false\n        });\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: stream => 0,\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path) {\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || \"binary\";\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error(\"Invalid encoding type \\\"\".concat(opts.encoding, \"\\\"\"));\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices() {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var randomBuffer = new Uint8Array(1024),\n          randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice(\"/dev\", \"random\", randomByte);\n        FS.createDevice(\"/dev\", \"urandom\", randomByte);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories() {\n        FS.mkdir(\"/proc\");\n        var proc_self = FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount() {\n            var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStreamChecked(fd);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: () => stream.path\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams() {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n        var stdin = FS.open(\"/dev/stdin\", 0);\n        var stdout = FS.open(\"/dev/stdout\", 1);\n        var stderr = FS.open(\"/dev/stderr\", 1);\n      },\n      ensureErrnoError() {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.name = \"ErrnoError\";\n          this.node = node;\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n          this.setErrno(errno);\n          this.message = \"FS error\";\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [44].forEach(code => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit() {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS\n        };\n      },\n      init(input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit() {\n        FS.init.initialized = false;\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == \"string\") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },\n      createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          try {\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n          var doXHR = (from, to) => {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            xhr.responseType = \"arraybuffer\";\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            }\n            return intArrayFromString(xhr.responseText || \"\", true);\n          };\n          var lazyArray = this;\n          lazyArray.setDataGetter(chunkNum => {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n            if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n        if (typeof XMLHttpRequest != \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(key => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            FS.forceLoadFile(node);\n            return fn.apply(null, arguments);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return {\n            ptr: ptr,\n            allocated: true\n          };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      }\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -54;\n          }\n          throw e;\n        }\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = stat.mode;\n        HEAPU32[buf + 8 >> 2] = stat.nlink;\n        HEAP32[buf + 12 >> 2] = stat.uid;\n        HEAP32[buf + 16 >> 2] = stat.gid;\n        HEAP32[buf + 20 >> 2] = stat.rdev;\n        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n        HEAP32[buf + 32 >> 2] = 4096;\n        HEAP32[buf + 36 >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;\n        tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;\n        tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;\n        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      varargs: undefined,\n      get() {\n        var ret = HEAP32[+SYSCALLS.varargs >> 2];\n        SYSCALLS.varargs += 4;\n        return ret;\n      },\n      getp() {\n        return SYSCALLS.get();\n      },\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      }\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[__environ + i * 4 >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(string => bufSize += string.length + 1);\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n        return e.errno;\n      }\n    }\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break;\n        if (typeof offset !== \"undefined\") {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n        return e.errno;\n      }\n    }\n    var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n        return e.errno;\n      }\n    }\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (typeof offset !== \"undefined\") {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n        return e.errno;\n      }\n    }\n    var isLeapYear = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    var arraySum = (array, index) => {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {}\n      return sum;\n    };\n    var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var addDays = (date, days) => {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n      return newDate;\n    };\n    var writeArrayToMemory = (array, buffer) => {\n      HEAP8.set(array, buffer);\n    };\n    var _strftime = (s, maxsize, format, tm) => {\n      var tm_zone = HEAPU32[tm + 40 >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\",\n        \"%Ec\": \"%c\",\n        \"%EC\": \"%C\",\n        \"%Ex\": \"%m/%d/%y\",\n        \"%EX\": \"%H:%M:%S\",\n        \"%Ey\": \"%y\",\n        \"%EY\": \"%Y\",\n        \"%Od\": \"%d\",\n        \"%Oe\": \"%e\",\n        \"%OH\": \"%H\",\n        \"%OI\": \"%I\",\n        \"%Om\": \"%m\",\n        \"%OM\": \"%M\",\n        \"%OS\": \"%S\",\n        \"%Ou\": \"%u\",\n        \"%OU\": \"%U\",\n        \"%OV\": \"%V\",\n        \"%Ow\": \"%w\",\n        \"%OW\": \"%W\",\n        \"%Oy\": \"%y\"\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n      }\n      var WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n      var MONTHS = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n      function leadingSomething(value, digits, character) {\n        var str = typeof value == \"number\" ? value.toString() : value || \"\";\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n        return str;\n      }\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, \"0\");\n      }\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n        return compare;\n      }\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n          case 1:\n            return janFourth;\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n      function getWeekBasedYear(date) {\n        var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          }\n          return thisDate.getFullYear();\n        }\n        return thisDate.getFullYear() - 1;\n      }\n      var EXPANSION_RULES_2 = {\n        \"%a\": date => WEEKDAYS[date.tm_wday].substring(0, 3),\n        \"%A\": date => WEEKDAYS[date.tm_wday],\n        \"%b\": date => MONTHS[date.tm_mon].substring(0, 3),\n        \"%B\": date => MONTHS[date.tm_mon],\n        \"%C\": date => {\n          var year = date.tm_year + 1900;\n          return leadingNulls(year / 100 | 0, 2);\n        },\n        \"%d\": date => leadingNulls(date.tm_mday, 2),\n        \"%e\": date => leadingSomething(date.tm_mday, 2, \" \"),\n        \"%g\": date => getWeekBasedYear(date).toString().substring(2),\n        \"%G\": date => getWeekBasedYear(date),\n        \"%H\": date => leadingNulls(date.tm_hour, 2),\n        \"%I\": date => {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        \"%j\": date => leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3),\n        \"%m\": date => leadingNulls(date.tm_mon + 1, 2),\n        \"%M\": date => leadingNulls(date.tm_min, 2),\n        \"%n\": () => \"\\n\",\n        \"%p\": date => {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return \"AM\";\n          }\n          return \"PM\";\n        },\n        \"%S\": date => leadingNulls(date.tm_sec, 2),\n        \"%t\": () => \"\\t\",\n        \"%u\": date => date.tm_wday || 7,\n        \"%U\": date => {\n          var days = date.tm_yday + 7 - date.tm_wday;\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        \"%V\": date => {\n          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n            val++;\n          }\n          if (!val) {\n            val = 52;\n            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n            if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) {\n              val++;\n            }\n          } else if (val == 53) {\n            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n            if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n          }\n          return leadingNulls(val, 2);\n        },\n        \"%w\": date => date.tm_wday,\n        \"%W\": date => {\n          var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        \"%y\": date => (date.tm_year + 1900).toString().substring(2),\n        \"%Y\": date => date.tm_year + 1900,\n        \"%z\": date => {\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = off / 60 * 100 + off % 60;\n          return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n        },\n        \"%Z\": date => date.tm_zone,\n        \"%%\": () => \"%\"\n      };\n      pattern = pattern.replace(/%%/g, \"\\0\\0\");\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.includes(rule)) {\n          pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      pattern = pattern.replace(/\\0\\0/g, \"%\");\n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    };\n    var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);\n    var getCFunc = ident => {\n      var func = Module[\"_\" + ident];\n      return func;\n    };\n    var stringToUTF8OnStack = str => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      var toC = {\n        \"string\": str => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        \"array\": arr => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n      function convertReturnValue(ret) {\n        if (returnType === \"string\") {\n          return UTF8ToString(ret);\n        }\n        if (returnType === \"boolean\") return Boolean(ret);\n        return ret;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n      ret = onDone(ret);\n      return ret;\n    };\n    InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = \"InternalError\";\n      }\n    };\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = \"BindingError\";\n      }\n    };\n    init_ClassHandle();\n    init_embind();\n    init_RegisteredPointer();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    handleAllocatorInit();\n    init_emval();\n    var FSNode = function (parent, name, mode, rdev) {\n      if (!parent) {\n        parent = this;\n      }\n      this.parent = parent;\n      this.mount = parent.mount;\n      this.mounted = null;\n      this.id = FS.nextInode++;\n      this.name = name;\n      this.mode = mode;\n      this.node_ops = {};\n      this.stream_ops = {};\n      this.rdev = rdev;\n    };\n    var readMode = 292 | 73;\n    var writeMode = 146;\n    Object.defineProperties(FSNode.prototype, {\n      read: {\n        get: function () {\n          return (this.mode & readMode) === readMode;\n        },\n        set: function (val) {\n          val ? this.mode |= readMode : this.mode &= ~readMode;\n        }\n      },\n      write: {\n        get: function () {\n          return (this.mode & writeMode) === writeMode;\n        },\n        set: function (val) {\n          val ? this.mode |= writeMode : this.mode &= ~writeMode;\n        }\n      },\n      isFolder: {\n        get: function () {\n          return FS.isDir(this.mode);\n        }\n      },\n      isDevice: {\n        get: function () {\n          return FS.isChrdev(this.mode);\n        }\n      }\n    });\n    FS.FSNode = FSNode;\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n    var wasmImports = {\n      d: ___cxa_throw,\n      n: __embind_finalize_value_array,\n      l: __embind_finalize_value_object,\n      w: __embind_register_bigint,\n      G: __embind_register_bool,\n      h: __embind_register_class,\n      g: __embind_register_class_constructor,\n      c: __embind_register_class_function,\n      q: __embind_register_class_property,\n      F: __embind_register_emval,\n      p: __embind_register_enum,\n      i: __embind_register_enum_value,\n      t: __embind_register_float,\n      a: __embind_register_function,\n      j: __embind_register_integer,\n      e: __embind_register_memory_view,\n      u: __embind_register_std_string,\n      r: __embind_register_std_wstring,\n      o: __embind_register_value_array,\n      b: __embind_register_value_array_element,\n      m: __embind_register_value_object,\n      f: __embind_register_value_object_field,\n      H: __embind_register_void,\n      I: __emval_decref,\n      J: __emval_incref,\n      k: __emval_take_value,\n      s: _abort,\n      E: _emscripten_memcpy_js,\n      y: _emscripten_resize_heap,\n      z: _environ_get,\n      A: _environ_sizes_get,\n      B: _fd_close,\n      D: _fd_read,\n      v: _fd_seek,\n      C: _fd_write,\n      x: _strftime_l\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports[\"L\"])();\n    var _malloc = Module[\"_malloc\"] = a0 => (_malloc = Module[\"_malloc\"] = wasmExports[\"M\"])(a0);\n    var _free = Module[\"_free\"] = a0 => (_free = Module[\"_free\"] = wasmExports[\"N\"])(a0);\n    var ___getTypeName = a0 => (___getTypeName = wasmExports[\"P\"])(a0);\n    var __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = () => (__embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = wasmExports[\"Q\"])();\n    var ___errno_location = () => (___errno_location = wasmExports[\"__errno_location\"])();\n    var stackSave = () => (stackSave = wasmExports[\"R\"])();\n    var stackRestore = a0 => (stackRestore = wasmExports[\"S\"])(a0);\n    var stackAlloc = a0 => (stackAlloc = wasmExports[\"T\"])(a0);\n    var ___cxa_increment_exception_refcount = a0 => (___cxa_increment_exception_refcount = wasmExports[\"__cxa_increment_exception_refcount\"])(a0);\n    var ___cxa_is_pointer_type = a0 => (___cxa_is_pointer_type = wasmExports[\"U\"])(a0);\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = (a0, a1, a2, a3, a4) => (dynCall_jiji = Module[\"dynCall_jiji\"] = wasmExports[\"V\"])(a0, a1, a2, a3, a4);\n    var dynCall_viijii = Module[\"dynCall_viijii\"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viijii = Module[\"dynCall_viijii\"] = wasmExports[\"W\"])(a0, a1, a2, a3, a4, a5, a6);\n    var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = wasmExports[\"X\"])(a0, a1, a2, a3, a4, a5, a6);\n    var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = wasmExports[\"Y\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n    var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = wasmExports[\"Z\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    Module[\"ccall\"] = ccall;\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return moduleArg.ready;\n  };\n})();\nexport default Module;"],"names":["_scriptDir","Module","document","currentScript","src","undefined","moduleArg","arguments","length","readyPromiseResolve","readyPromiseReject","Promise","resolve","reject","read_","readAsync","readBinary","moduleOverrides","Object","assign","thisProgram","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","scriptDirectory","self","location","href","indexOf","substr","replace","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","Uint8Array","response","onload","onerror","status","wasmBinary","wasmMemory","out","console","log","bind","err","error","WebAssembly","abort","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","ABORT","updateMemoryViews","b","buffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runDependencies","runDependencyWatcher","dependenciesFulfilled","addRunDependency","id","removeRunDependency","clearInterval","callback","what","e","RuntimeError","wasmBinaryFile","path","tempDouble","tempI64","dataURIPrefix","isDataURI","filename","startsWith","getBinarySync","file","instantiateArrayBuffer","binaryFile","imports","receiver","fetch","then","credentials","catch","getBinaryPromise","binary","instantiate","instance","reason","concat","callRuntimeCallbacks","callbacks","shift","ExceptionInfo","excPtr","this","ptr","set_type","type","get_type","set_destructor","destructor","get_destructor","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","init","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","get_exception_ptr","___cxa_is_pointer_type","adjusted","tupleRegistrations","runDestructors","destructors","pop","del","simpleReadValueFromPointer","pointer","InternalError","embind_charCodes","BindingError","awaitingDependencies","registeredTypes","typeDependencies","throwInternalError","message","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","i","registerType","forEach","Array","unregisteredTypes","registered","dt","hasOwnProperty","push","structRegistrations","readLatin1String","ret","c","throwBindingError","rawType","registeredInstance","options","TypeError","name","ignoreDuplicateRegistrations","cb","sharedRegisterType","delayFunction","GenericWireTypeSize","throwInstanceAlreadyDeleted","obj","$$","ptrType","registeredClass","finalizationRegistry","detachFinalizer","handle","releaseClassHandle","count","value","smartPtr","smartPtrType","rawDestructor","runDestructor","downcastPointer","ptrClass","desiredClass","baseClass","rv","downcast","registeredPointers","getInheritedInstanceCount","keys","registeredInstances","getLiveInheritedInstances","k","deletionQueue","flushPendingDeletes","deleteScheduled","setDelayFunction","fn","getInheritedInstance","class_","upcast","getBasestPointer","makeClassHandle","prototype","record","attachFinalizer","create","RegisteredPointer_fromWireType","rawPointer","getPointee","makeDefaultHandle","isSmartPointer","instancePrototype","pointeeType","toType","actualType","getActualType","registeredPointerRecord","call","isConst","constPointerType","pointerType","dp","FinalizationRegistry","info","register","unregister","ClassHandle","makeLegalFunctionName","f","charCodeAt","createNamedFunction","body","apply","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","argCount","exposePublicSymbol","numArguments","RegisteredClass","constructor","pureVirtualFunctions","upcastPointer","constNoSmartPtrRawPointerToWireType","isReference","embindRepr","handleClass","genericPointerToWireType","rawConstructor","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","readPointer","RegisteredPointer","rawGetPointee","destructorFunction","wasmTable","UnboundTypeError","replacePublicSymbol","wasmTableMirror","getWasmTableEntry","funcPtr","func","get","dynCall","sig","args","includes","dynCallLegacy","embind__requireFunction","signature","rawFunction","argCache","fp","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","map","join","heap32VectorToArray","firstElement","array","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isAsync","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","argumentList","Function","dummy","r","newFunc","validateThis","this_","HandleAllocator","allocated","freelist","emval_handles","__emval_decref","reserved","refcount","free","count_emval_handles","toValue","allocate","enumReadValueFromPointer","width","signed","requireRegisteredType","impl","v","t","toString","floatReadValueFromPointer","integerReadValueFromPointer","stringToUTF8Array","str","heap","outIdx","maxBytesToWrite","startIdx","endIdx","u","stringToUTF8","outPtr","lengthBytesUTF8","len","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","endPtr","decode","subarray","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","lengthBytesUTF32","growMemory","size","pages","byteLength","grow","ENV","getEnvStrings","strings","env","navigator","languages","x","PATH","isAbs","charAt","splitPath","exec","slice","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","normalize","isAbsolute","trailingSlash","split","filter","p","dirname","result","root","dir","basename","lastSlash","paths","join2","l","randomFill","view","crypto","getRandomValues","initRandomFill","PATH_FS","resolvedPath","resolvedAbsolute","FS","cwd","relative","from","to","trim","arr","start","end","fromParts","toParts","Math","min","samePartsLength","outputParts","FS_stdin_getChar_buffer","intArrayFromString","stringy","dontAddNull","u8array","numBytesWritten","baseErrorType","errorName","errorClass","TTY","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","node","rdev","ErrnoError","seekable","close","fsync","read","offset","pos","get_char","bytesRead","timestamp","Date","now","write","put_char","default_tty_ops","window","prompt","readline","FS_stdin_getChar","val","ioctl_tcgets","c_iflag","c_oflag","c_cflag","c_lflag","c_cc","ioctl_tcsets","optional_actions","data","ioctl_tiocgwinsz","default_tty1_ops","mmapAlloc","MEMFS","ops_table","mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","max","oldContents","set","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","ceil","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","key","newname","oldpath","position","canOwn","whence","prot","flags","byteOffset","mmapFlags","asyncLoad","noRunDep","dep","arrayBuffer","condition","text","event","preloadPlugins","FS_getMode","canRead","canWrite","mounts","devices","streams","nextInode","nameTable","currentPath","initialized","ignorePermissions","filesystems","syncFSRequests","lookupPath","opts","follow_mount","recurse_count","current","current_path","islast","isMountpoint","mounted","follow","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","FSNode","destroyNode","isSocket","flagsToPermissionString","flag","perms","nodePermissions","mayCreate","mayDelete","isdir","errno","mayOpen","MAX_OPEN_FDS","nextfd","fd","getStreamChecked","getStream","createStream","FSStream","shared","defineProperties","object","isRead","isWrite","isAppend","closeStream","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","next","mkdir","mkdirTree","dirs","d","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","Error","FS_modeStringToFlags","created","ungotten","readFiles","isClosed","getdents","seeking","bytesWritten","munmap","ioctl","cmd","arg","readFile","encoding","buf","writeFile","actualNumBytes","ArrayBuffer","isView","chdir","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","createStandardStreams","ensureErrnoError","setErrno","code","stack","staticInit","quit","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","createDataFile","forceLoadFile","isDevice","isFolder","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","lazyArray","setRequestHeader","overrideMimeType","doXHR","_length","_chunkSize","writeChunks","SYSCALLS","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","getStreamFromFD","doStat","abs","floor","getTime","doMsync","addr","varargs","getp","getStr","isLeapYear","year","MONTH_DAYS_LEAP","MONTH_DAYS_REGULAR","writeArrayToMemory","_strftime","s","maxsize","format","tm","tm_zone","date","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","character","leadingNulls","compareByDay","date1","date2","sgn","compare","getFullYear","getMonth","getDate","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","days","newDate","leap","currentMonth","daysInCurrentMonth","setDate","setMonth","setFullYear","addDays","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","substring","twelveHour","index","sum","arraySum","jan1","dec31","off","ahead","bytes","super","codes","embind_init_charCodes","other","leftClass","left","rightClass","right","preservePointerOnDelete","o","clone","getPrototypeOf","has","readMode","writeMode","createPreloadedFile","dontCreateFile","preFinish","fullname","processData","byteArray","finish","fileData","FS_createDataFile","Browser","handled","plugin","FS_handledByPreloadPlugin","calledRun","wasmImports","n","rawTupleType","reg","elements","elementsLength","elementTypes","elt","getterReturnType","setterArgumentType","getterContext","setter","setterContext","structType","fieldRecords","fields","fieldTypes","field","fieldName","w","primitiveType","minRange","maxRange","G","trueValue","falseValue","wt","h","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","__derivedClasses","referenceConverter","pointerConverter","constPointerConverter","g","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","rawInvoker","context","isPureVirtual","unboundTypesHandler","Symbol","method","className","memberFunction","q","getterSignature","setterSignature","desc","enumerable","configurable","defineProperty","F","isSigned","ctor","values","rawEnumType","enumValue","enumType","Enum","Value","a","invokerArgsArray","j","fromWireType","bitshift","isUnsignedType","dataTypeIndex","TA","decodeMemoryView","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","stringSegment","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","constructorSignature","H","isVoid","I","J","E","dest","num","copyWithin","y","requestedSize","oldSize","maxHeapSize","multiple","cutDown","overGrownHeapSize","z","__environ","environ_buf","bufSize","string","stringToAscii","A","penviron_count","penviron_buf_size","B","D","iov","iovcnt","pnum","curr","doReadv","offset_low","offset_high","newOffset","lo","hi","NaN","isNaN","C","doWritev","loc","wasmExports","receiveInstance","module","exports","instantiateStreaming","createWasm","a0","stackSave","stackRestore","stackAlloc","run","doRun","postRun","preRun","setTimeout","a1","a2","a3","a4","a5","a6","a7","a8","a9","ident","returnType","toC","stringToUTF8OnStack","getCFunc","cArgs","converter","Boolean","convertReturnValue","onDone","runCaller","ready"],"sourceRoot":""}